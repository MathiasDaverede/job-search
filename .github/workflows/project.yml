name: Project

# Run GitHub Actions only on pull requests to stay within the free plan limits (500 MB storage, 2000 minutes/month).
# Pull requests to 'develop' are for feature branches.
# Pull requests to 'main' are for release or hotfix branches.
on:
  pull_request:
    branches: [main, develop]

permissions:
  contents: write # For committing changes to VERSION.md and CHANGELOG.md
  pull-requests: read # For fetching pull request data via GitHub API
  issues: read # For fetching issue titles via GitHub API

jobs:
  test-project:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Create .env.local with host data
      run: |
        file_content="USER_NAME=$(whoami)\n"
        file_content+="USER_ID=$(id -u)\n"
        file_content+="GROUP_ID=$(id -g)\n"
        file_content+="MARIADB_DATABASE_NAME=job_search\n"
        file_content+="MARIADB_ROOT_PASSWORD=root"
        echo -e $file_content > .env.local

    - name: Display .env.local
      run: cat .env.local

    - name: Build and start containers
      run: docker compose --env-file .env.local up -d

    - name: Check containers status
      run: |
        docker ps -a
        docker logs job-search-web-1

    - name: Verify host's rights
      run: |
        echo "$(whoami) $(id -u) $(id -g)"
        ls -l 
        echo "Executables files :"
        ls -l bin/

    - name: Verify container's rights in /var/www/
      run: |
        echo "$(docker compose exec web whoami) $(docker compose exec web id -u) $(docker compose exec web id -g)"
        docker compose exec web ls -l /var/ | grep www
        docker compose exec web ls -l /var/www/
        echo  "Executables files :"
        docker compose exec web ls -l /var/www/bin/

    - name: Cache Composer dependencies
      uses: actions/cache@v4
      with:
        path: vendor
        key: composer-${{ hashFiles('composer.lock') }}
        restore-keys: composer-

    - name: Cache Importmap dependencies
      uses: actions/cache@v4
      with:
        path: assets/vendor
        key: importmap-${{ hashFiles('importmap.php') }}
        restore-keys: importmap-

    - name: Install Composer dependencies
      run: docker compose exec web composer install --no-interaction --optimize-autoloader
      
    - name: Run Doctrine migrations
      run: docker compose exec web bin/console doctrine:migrations:migrate --no-interaction

    - name: Cache Sass assets
      uses: actions/cache@v4
      with:
        path: var/sass
        key: sass-${{ hashFiles('assets/**/*.scss') }}
        restore-keys: sass-

    - name: Generate Sass assets
      run: docker compose exec web bin/console sass:build

    - name: Check Composer platform requirements
      run: docker compose exec web composer check-platform-reqs

    - name: Check Symfony requirements
      run: docker compose exec web symfony check:requirements

    - name: Check Symfony security issues in project dependencies
      run: docker compose exec web symfony check:security

    - name: Audit importmap
      run: docker compose exec web bin/console importmap:audit

    - name: Unit tests
      run: |
        chmod +x ./bin/phpunit
        docker compose exec web bin/console --env=test doctrine:database:create
        docker compose exec web bin/console --env=test doctrine:schema:create
        docker compose exec web bin/console --env=test doctrine:fixtures:load --no-interaction
        docker compose exec web bin/phpunit

    - name: Stop and remove Docker containers
      run: docker compose --env-file .env.local down

    - name: Debug test-project job
      run: |
        echo "Test-project job executed!"
        echo "Event: ${{ github.event_name }}"
        echo "Ref: ${{ github.event.pull_request.head.ref }}"
        echo "Actor: ${{ github.actor }}"

  update-version-changelog:
    # Only if precedent job succeed and come from a pull request on main (release or hotfix)
    needs: test-project
    if: github.event.pull_request.base.ref == 'main'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches the full Git history to analyse tags
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Validate branch name and extract version
        id: pr_info
        run: |
          PR_BRANCH=${{ github.event.pull_request.head.ref }}
          if [[ ! "$PR_BRANCH" =~ ^(release|hotfix)/[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: PR branch must be 'release/X.Y.Z' or 'hotfix/X.Y.Z'"
            exit 1
          fi
          VERSION=$(echo "$PR_BRANCH" | sed -E 's/^(release|hotfix)\/([0-9]+\.[0-9]+\.[0-9]+)$/\2/')
          echo "NEW_VERSION=v$VERSION" >> $GITHUB_ENV
          echo "PR_BRANCH=$PR_BRANCH" >> $GITHUB_ENV
          
      - name: Update VERSION.md
        run: echo "${{ env.NEW_VERSION }}" > VERSION.md

      - name: Update CHANGELOG.md
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs').promises;
            const { Octokit } = require('@octokit/rest');
            const github = new Octokit({ auth: process.env.GITHUB_TOKEN });

            // Get the previous tag
            let previousTag = '';
            let tagDate = '1970-01-01';
            try {
              const { data: tags } = await github.rest.repos.listTags({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              if (tags.length > 0) {
                previousTag = tags[0].name;
                const { data: commit } = await github.rest.git.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: tags[0].commit.sha,
                });
                tagDate = commit.committer.date.split('T')[0];
              }
            } catch (error) {
              console.log('No previous tags found or error fetching tags:', error.message);
            }

            // Get merged PRs since the last tag
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              base: 'main',
              sort: 'updated',
              direction: 'desc',
            });

            let changelogContent = `## ${{ env.NEW_VERSION }} - ${new Date().toISOString().split('T')[0]}\n`;
            changelogContent += `[Release ${{ env.NEW_VERSION }}](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/${{ env.NEW_VERSION }})\n`;

            const prRegex = /^(\d+)\s+(feat|fix):\s*(.+?)(?:\s*\[closes\s*#(\d+)\])?$/;
            for (const pr of prs) {
              if (pr.merged_at && pr.merged_at > tagDate) {
                const match = pr.title.match(prRegex);
                if (match) {
                  const prNumber = match[1];
                  const type = match[2];
                  const description = match[3];
                  const issueNumber = match[4];

                  if (issueNumber) {
                    try {
                      const { data: issue } = await github.rest.issues.get({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                      });
                      changelogContent += `- ${type} [#${issueNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issueNumber}) ${issue.title}\n`;
                    } catch (error) {
                      console.log(`Warning: Issue #${issueNumber} not found for PR #${prNumber}, using PR title`);
                      changelogContent += `- ${type} [#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}) ${description}\n`;
                    }
                  } else {
                    console.log(`Info: No issue linked for PR #${prNumber}, using PR title`);
                    changelogContent += `- ${type} [#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}) ${description}\n`;
                  }
                } else {
                  console.log(`Warning: Skipping PR #${pr.number}: Title does not match 'feat|fix' format`);
                }
              }
            }

            if (!prs.some(pr => pr.merged_at && pr.merged_at > tagDate)) {
              console.log('Warning: No merged PRs found since', tagDate, ', changelog will only include header');
            }

            const changelogHeader = '# Changelog\nAll notable changes to this project are documented in this file.\n\n';
            let existingChangelog = '';
            try {
              existingChangelog = await fs.readFile('CHANGELOG.md', 'utf8');
            } catch (error) {
              console.log('No existing CHANGELOG.md found, creating new one');
            }

            await fs.writeFile('CHANGELOG.md', changelogHeader + changelogContent + '\n' + existingChangelog);

      - name: Output files content
        run: |
          echo "Generated version ${{ env.NEW_VERSION }}"
          echo "VERSION.md content:"
          cat VERSION.md
          echo "CHANGELOG.md content:"
          cat CHANGELOG.md

      - name: Commit and push files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add VERSION.md CHANGELOG.md
          git commit -m "Update VERSION.md to ${{ env.NEW_VERSION }} and CHANGELOG.md"
          git push origin ${{ env.PR_BRANCH }}

      - name: Debug update-version-changelog job
        run: |
          echo "Update-version-changelog job executed!"
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.event.pull_request.head.ref }}"
          echo "Actor: ${{ github.actor }}"
